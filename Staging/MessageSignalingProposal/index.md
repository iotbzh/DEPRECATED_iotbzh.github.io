---
Title: Message Signalling Potential Architecture for AGL
Author: Fulup Ar Foll (IoT.bzh)
Date: 30-06-2016

Category: architecture
Tags: architecture, signal, message
Layout: technical-proposal
---

# Message Signaling Potential Architecture for AGL

## Context

Automotive applications need to understand in real time the context in which 
vehicles operate. In order to so it is critical for automotive application to
rely on a simple, fast and secure method to access data generated by the multiple
sensors/ECU embedded in any modern cars.

This signalling problem is neither new, neither unique to the automotive and multiple
solutions often described as Message Broker or Signalling Gateway have been around
for a while. In the context of Linux for Automotive, the "Automotive Message Broker Daemon (aka AMBd)" 
as been around for few years and is pretty well known within the Linux Automotive community.

The present discussion is a proposal to enhance existing signalling/message models.
Our proposal relies on [[AppFw]] binder/bindings model to minimise complexity while keeping
the system fast and secure. Proposing a model with multiple transport options and a full
set of security feature to protect the agent generating the signal as as well as the consuming them.

## Architecture

The proposal leverages [[APbinder]] event notification capabilities to
implement a new messaging/signalling model based on distributed agents.
A distributed architecture as as multiple advantage:
- it avoid to concentrate complexity in a single big/fat component.
- it leverage naturally multiple ECU and existing network architecture
- it simplify security by enabling isolation and sandboxing
- it clearly separate responsibility and simplify resolution of conflicts

![image](./distributed-arch.svg "Distributed Architecture")

Each agent exposes to services/applications the signal it is responsible for. Technically an agent is 
a standard [[AppFw]] service. Therefor Signal/Agent inherits of security protection through SMACK, access control through Cynara, transparency of API to transport layer, live cycle management, ...

Like any other [[AppFw]] service Signal/Agent is compose of a set of bindings that are assemble into in a an [[APbinder]]. Nevertheless as we will see later in order to improve signal processing performance we propose that Signalling/Binders to be implemented as a special instance of a generic [[APbinder]].

This model allows to implement low level dependencies as independent bindings. Those bindings when developed are somehow like  like "Lego Bricks". They can be spread or grouped within one or multiple agents depending on deployment constrains (performance, multi-ECU, security isolation constrains, ...).

## Event Signalling Model

Version 1.0 of [[APbinder]] already includes event notification mechanisms. We propose to reuse those mechanisms as foundation for the new AGL signal/messaging design. While previous event notification was limited to basic events (doc 7.10 of [[AppCore]]), current Master posted on Gerrit [[APbinder]] proposes a model with a new registration mechanism to allows publish/subscribe implementations (i.e. HellowWorld.c [[APsamples]]).

The main idea is to implement the low level logic (i.e. CAN handling) as a set of standard AppFw/Bindings. On one hand those low level bindings could be stacked within a shared [[APbinder]]. On the other hand virtual signal with their attached business logic could compose those low level bindings and expose a non hardware dependant abstraction to applications.

While current AppFw/Binder could technically allow to implement such a model, two major improvements would be welcome. First the amount of exchanged information in between low level bindings and business logic would benefit from a shortcut layer to boost inter-bindings exchanges. Secondly a generic set of facilities to handle subscribe registration would deeply simplify the work of developers.

--------- | ---------
![image](./agent-arch.svg "Agent Architecture") | ![image](./agent-sample.svg "Agent Architecture")

## Security Model

Nothing special as Signal/Agents are standard AppFw/Services they inherit from all protection provided by the AppFw, each Agent run with its own SMACK label and fine grain access control is operated automatically at transport level through Cynara.

## Composition

An important element for long term maintenance is to keep Signal/Bindings as self contains as possible.  Changing a Low level GPS binding should not have a minimal or better no impact at all on existing virtual signal (i.e. GeoPosition). On the same way changing the business logic should be transparent to applications.

In order to do so, binding should use a normalised interface to talk with the binder and no direct dependencies in between  bindings should be allow. The proposal is to reuse an interface mechanism equivalent to the one use to provide APIs transparency at transport layer. 

**Multi-ECU and Vehicule to Cloud interactions:** while this might not be a show stopper for current projects, it is obvious that in the near future Signal/Agent should supported a fully distributed architectures. 
Somme event may come from the cloud (i.e. request to start monitoring a given feature), some may come SmartCity and near by vehicules, and last but least some may come from an other ECU within the same vehicle or from a virtualise OS within the same ECU (I.e. cluster & IVI). 
In order to do so Bindings should enable composition within one or more [[APbinder]] inside the same ECU. Furthermore they should also support chaining with the outside world.

![image](./cloud-arch.svg "CLoud & Multi-ECU Architecture")

1. Application request Virtual Signal exactly like if it was low level signal
2. Agent Signal has direct direct to low level signal
3. Agent need to proxy to an other agent inside the same ECU to access the signal
4. Signal is not present on current ECU. Request has to be proxy to the outside world

## Work to be Done

As stated before the foundation for event signalling is already in place in development branch of [[APbinder]]. Nevertheless in order to provide a reel added value to developers missing components should be developed.

- **Agent Core Components**
    - Create a simple configuration model to move from low level signal description to something more generic that could help to abstract the hardware.
    - Implement a real publish subscribe mode on top of existing event model to support advanced functionalities like: getSignalEvery(signal, time), getSignalIf (signal, value, gt, xxx), etc ...
    - Choose a model to boost exchange of information in between binders, MemCache, Retis, ... and implement what ever is necessary on top to provide a real added value to developers.
    - Implement some form of introsception to allow application to discover the list of signal supported by a given agent.
- **Few Common Agents**
    - Provide at least a reference implementation for a generic CAN agent
    - Agent simulation, most developers may not have access to physical devices during development phase, some form of simulator would be more than welcome.
    - etc ...

## Reusing existing/legacy code

What ever final architecture will be chosen chosen, it is important not to forget how to leverage existing/legacy code within the new model. They are multiple source for reusable code that can be classified in two main categories:

- **Low Level** Typically those existing code interface with CAN-BUS or any other low level device. Some AMBd[[6]] plugins could be a good source of input for low level implementation. But also more community oriented projects like: ArduPilot/Rover[[7]] Barometer or Camera interfaces[[8]].
- **Virtual Signal** In many cases accessing to low level signal is not enough. Low level information might need to be compose (i.e. GPS+Gyro+Accel). Raw value might need to be processed (i.e.: change unit, average on the last xx seconds, ...). Writing this composition logic might be quite complex and reusing existing library like: LibEkNav for Kalman filtering [[9]] or Vrgimbal for 3 axes control[[10]] may help saving a lot of time.

## Proposal

In order to start moving forward one option would be to take a concrete example like a GeoPositioning service. In order to do so we could use a Porter+Cogent-Extention[[11]] that support both a GPS and a 9 axis sensor. We could  reuse some existing code like the one from Rover[[7]] to provide a fine grain positioning service and then interface this new GeoPositioning agent with an application like GpsNavi[[12]] to get a end-to-end demonstrator.



[AppFw]:  http://iot.bzh/download/public/2016/appfw/01_Introduction-to-AppFW-for-AGL-1.0.pdf "Application Framework"
[APcore]:  http://iot.bzh/download/public/2016/appfw/03_Documentation-AppFW-Core-1.0.pdf "AppFw Core"
[APmain]:  https://gerrit.automotivelinux.org/gerrit/#/q/project:src/app-framework-main "AppFw Main"
[APbinder]:  https://gerrit.automotivelinux.org/gerrit/#/q/project:src/app-framework-binder "AppFw Binder"
[APsamples]:  https://gerrit.automotivelinux.org/gerrit/gitweb?p=src/app-framework-binder.git;a=tree;f=bindings/samples "AppFw Samples"
[6]:  https://github.com/otcshare/automotive-message-broker
[7]:  http://ardupilot.org/rover/index.html
[8]:  https://github.com/ArduPilot/ardupilot/tree/master/libraries
[9]:  https://bitbucket.org/jbrandmeyer/libeknav/wiki/Home
[10]: http://ardupilot.org/rover/docs/common-vrgimbal.html
[11]: http://elinux.org/R-Car/Boards/Porter:PEXT01
[12]: https://github.com/gpsnavi/gpsnavi

