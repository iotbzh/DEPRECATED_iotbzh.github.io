---
title: Message Signalling Potential Architecture for AGL
author: Fulup Ar Foll (IoT.bzh)
date: 2016-06-30

categories: architecture, appfw
tags: architecture, signal, message
layout: techdoc

---

## Context

Automotive applications need to understand in real time the context in which 
vehicles operate. In order to do so, it is critical for automotive application to
rely on a simple, fast and secure method to access data generated by the multiple
sensors/ECU embedded in any modern cars.

This signalling problem is neither new, neither unique to the automotive and multiple
solutions often described as Message Broker or Signalling Gateway have been around
for a while. In the context of Linux for Automotive, the "Automotive Message Broker Daemon (aka AMBd)" 
has been around for few years and is pretty well known within the Linux Automotive community.

The present discussion is a proposal to enhance existing signaling/message models.
Our proposal relies on [[AppFw]] binder/bindings model to minimise complexity while keeping
the system fast and secure. Proposing a model with multiple transport options and a full
set of security feature to protect the agent generating the signal as well as consuming them.

## Architecture

The proposal leverages [[APbinder]] event notification capabilities to
implement a new messaging/signalling model based on distributed agents.
A distributed architecture has multiple advantages:
- it avoids to concentrate complexity in a single big/fat component.
- it leverages naturally multiple ECU and existing network architecture
- it simplifies security by enabling isolation and sandboxing
- it clearly separates responsibility and simplifies resolution of conflicts

![image](./distributed-arch.svg "Distributed Architecture")

Each agent exposes to services/applications the signal it is responsible for. Technically an agent is 
a standard [[AppFw]] service. Therefore Signal/Agent inherits of security protection through SMACK, access control through Cynara, transparency of API to transport layer, life cycle management, ...

Like any other [[AppFw]] service Signal/Agent is composed of a set of bindings that are assembled into in an [[APbinder]]. Nevertheless as we will see later in order to improve signal processing performance we propose that Signalling/Binders to be implemented as a special instance of a generic [[APbinder]].

This model allows to implement low level dependencies as independent bindings. Those bindings when developed are somehow like "Lego Bricks". They can be spread or grouped within one or multiple agents depending on deployment constraints (performance, multi-ECU, security isolation constraints, ...).

## Event Signaling Model

Version 1.0 of [[APbinder]] already includes event notification mechanisms. We propose to reuse those mechanisms as a foundation for the new AGL signal/messaging design. While previous event notification was limited to basic events (doc 7.10 of [[AppCore]]), current Master posted on Gerrit [[APbinder]] proposes a model with a new registration mechanism to allows publish/subscribe implementations (i.e. HellowWorld.c [[APsamples]]).

The main idea is to implement the low level logic (e.g. CAN handling) as a set of standard AppFw/Bindings. On one hand those low level bindings could be stacked within a shared [[APbinder]]. On the other hand virtual signals with their attached business logic could compose those low level bindings and expose a hardware-independent abstraction to applications.

While current AppFw/Binder could technically allow to implement such a model, two major improvements would be welcome. First the amount of exchanged information in between low level bindings and business logic would benefit from a shortcut layer to boost inter-bindings exchanges. Secondly a generic set of facilities to handle subscribers registrations would deeply simplify the work of developers.

--------- | ---------
![image](./agent-arch.svg "Agent Architecture") | ![image](./agent-sample.svg "Agent Architecture")

## Security Model

Nothing special as Signal/Agents are standard AppFw/Services they inherit from all protection provided by the AppFw, each Agent runs with its own SMACK label and fine grain access control is operated automatically at transport level through Cynara.

## Composition

An important element for long term maintenance is to keep Signal/Bindings as self contained as possible. Changing a Low level GPS binding should have a minimal or better no impact at all on existing virtual signals (i.e. GeoPosition). On the same way, changing the business logic should be transparent to applications.

In order to do so, bindings should use a normalised interface to talk with the binder and no direct dependencies in between bindings should be allowed. The proposal is to reuse an interface mechanism equivalent to the one used to provide APIs transparency at transport layer. 

**Multi-ECU and Vehicule to Cloud interactions:** while this might not be a show stopper for current projects, it is obvious that in the near future Signal/Agent should support a fully distributed architectures.
Some event may come from the cloud (i.e. request to start monitoring a given feature), some may come from SmartCity and nearby vehicules, and last but not least some may come from another ECU within the same vehicle or from a virtualized OS within the same ECU (e.g. cluster & IVI). 
In order to do so, Bindings should enable composition within one or more [[APbinder]] inside the same ECU. Furthermore they should also support chaining with the outside world.

![image](./cloud-arch.svg "CLoud & Multi-ECU Architecture")

1. Application requests Virtual Signal exactly like if it was a low level signal
2. Agent Signal has direct relation to low level signal
3. Agent needs to proxy to an other agent inside the same ECU to access the signal
4. Signal is not present on current ECU. Request has to be proxied to the outside world

## Work to be Done

As stated before, the foundation for event signaling is already in place in development branch of [[APbinder]]. Nevertheless in order to provide a real added value to developers missing components should be developed.

- **Agent Core Components**
    - Create a simple configuration model to move from low level signal description to something more generic that could help to abstract the hardware.
    - Implement a real publish/subscribe mode on top of existing event model to support advanced functionalities like: getSignalEvery(signal, time), getSignalIf (signal, value, gt, xxx), etc ...
    - Choose a model to boost exchange of information in between binders, MemCache, Redis, ... and implement what ever is necessary on top to provide a real added value to developers.
    - Implement some form of introsception to allow application to discover the list of signal supported by a given agent.
- **Few Common Agents**
    - Provide at least a reference implementation for a generic CAN agent
    - Agent simulation, most developers may not have access to physical devices during development phase, some form of simulator would be more than welcome.
    - etc ...

## Reusing existing/legacy code

Whatever the final architecture will be, it is important not to forget how to leverage existing/legacy code within the new model. There are multiple sources for reusable code that can be classified in two main categories:

- **Low Level** Typically those existing code interface with CAN-BUS or any other low level device. Some AMBd[[6]] plugins could be a good source of input for low level implementation. But also more community oriented projects like: ArduPilot/Rover[[7]] Barometer or Camera interfaces[[8]].
- **Virtual Signal** In many cases accessing to low level signal is not enough. Low level information might need to be composed (i.e. GPS+Gyro+Accel). Raw value might need to be processed (i.e.: change unit, average on the last xx seconds, ...). Writing this composition logic might be quite complex and reusing existing libraries like: LibEkNav for Kalman filtering [[9]] or Vrgimbal for 3 axes control[[10]] may help saving a lot of time.

## Proposal

In order to start moving forward one option would be to take a concrete example like a GeoPositioning service. In order to do so we could use a Porter+Cogent-Extension[[11]] that supports both a GPS and a 9 axis sensor. We could  reuse some existing code like the one from Rover[[7]] to provide a fine grain positioning service and then interface this new GeoPositioning agent with an application like GpsNavi[[12]] to get a end-to-end demonstrator.

[AppFw]:  http://iot.bzh/download/public/2016/appfw/01_Introduction-to-AppFW-for-AGL-1.0.pdf "Application Framework"
[APcore]:  http://iot.bzh/download/public/2016/appfw/03_Documentation-AppFW-Core-1.0.pdf "AppFw Core"
[APmain]:  https://gerrit.automotivelinux.org/gerrit/#/q/project:src/app-framework-main "AppFw Main"
[APbinder]:  https://gerrit.automotivelinux.org/gerrit/#/q/project:src/app-framework-binder "AppFw Binder"
[APsamples]:  https://gerrit.automotivelinux.org/gerrit/gitweb?p=src/app-framework-binder.git;a=tree;f=bindings/samples "AppFw Samples"
[6]:  https://github.com/otcshare/automotive-message-broker
[7]:  http://ardupilot.org/rover/index.html
[8]:  https://github.com/ArduPilot/ardupilot/tree/master/libraries
[9]:  https://bitbucket.org/jbrandmeyer/libeknav/wiki/Home
[10]: http://ardupilot.org/rover/docs/common-vrgimbal.html
[11]: http://elinux.org/R-Car/Boards/Porter:PEXT01
[12]: https://github.com/gpsnavi/gpsnavi
